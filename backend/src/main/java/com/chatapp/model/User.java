package com.chatapp.model;

// ============================================================================
// IMPORTS
// ============================================================================

// JPA (Jakarta Persistence API) annotations for ORM (Object-Relational Mapping)
// These annotations map Java objects to database tables automatically
import jakarta.persistence.*;

import java.util.List;  // For storing list of user roles

/**
 * ============================================================================
 * USER ENTITY - Represents a user in the MySQL database
 * ============================================================================
 * 
 * WHAT IS A JPA ENTITY?
 * ---------------------
 * An Entity is a Java class that represents a table in a relational database.
 * JPA (Java Persistence API) automatically handles the conversion between
 * Java objects and database rows - this is called ORM (Object-Relational Mapping).
 * 
 * Each instance of this User class = One row in the "users" table
 * 
 * MAPPING EXAMPLE:
 * ----------------
 *   Java Object (User)              <-->    Database Row (users table)
 *   ---------------------------            ---------------------------
 *   user.id = 1                             id = 1
 *   user.email = "john@example.com"         email = "john@example.com"
 *   user.password = "$2a$10$..."            password = "$2a$10$..."
 *   user.displayName = "John"               display_name = "John"
 *   user.status = "ACTIVE"                  status = "ACTIVE"
 * 
 * DATABASE TABLES CREATED BY THIS ENTITY:
 * ---------------------------------------
 * 1. Main table (users):
 *    CREATE TABLE users (
 *        id BIGINT AUTO_INCREMENT PRIMARY KEY,
 *        email VARCHAR(255) NOT NULL UNIQUE,
 *        password VARCHAR(255) NOT NULL,
 *        display_name VARCHAR(255),
 *        status VARCHAR(255) NOT NULL
 *    );
 * 
 * 2. Roles table (user_roles) - Created by @ElementCollection:
 *    CREATE TABLE user_roles (
 *        user_id BIGINT REFERENCES users(id),
 *        role VARCHAR(255)
 *    );
 * 
 * USER STATUS LIFECYCLE:
 * ----------------------
 * 1. User registers          → status = "PENDING_VERIFICATION"
 * 2. User verifies email     → status = "ACTIVE"
 * 3. (Future) Admin bans     → status = "BANNED"
 * 
 * IMPORTANT: Only "ACTIVE" users can log in!
 * 
 * SECURITY NOTES:
 * ---------------
 * - Password is ALWAYS stored as BCrypt hash, NEVER plain text
 * - Even database admins cannot see the actual password
 * - BCrypt includes salt, so same password → different hashes each time
 * - Example: "password123" → "$2a$10$N9qo8uLOickgx2ZMRZoMye..."
 * 
 * @see UserRepository For database operations (find, save, delete)
 * @see AuthService Where User objects are created and updated
 */
@Entity  // Tells JPA: "This class represents a database table"
@Table(name = "users")  // Specifies table name (default would be "user" which is reserved in some DBs)
public class User {
    
    // ========================================================================
    // PRIMARY KEY - Unique identifier for each user
    // ========================================================================
    
    /**
     * Unique identifier for each user (auto-generated by MySQL).
     * 
     * ANNOTATIONS EXPLAINED:
     * @Id - Marks this field as the primary key (unique identifier)
     * @GeneratedValue - Database auto-generates this value (we don't set it manually)
     * GenerationType.IDENTITY - Uses MySQL's AUTO_INCREMENT feature
     * 
     * WHY USE LONG INSTEAD OF INT?
     * - Long can hold much larger values (up to 9 quintillion)
     * - Prevents overflow issues with many users
     * - Standard practice for database IDs in enterprise apps
     * - Wrapper type Long (not primitive long) allows null for new entities
     */
    @Id  // This field is the primary key
    @GeneratedValue(strategy = GenerationType.IDENTITY)  // AUTO_INCREMENT
    private Long id;
    
    // ========================================================================
    // USER CREDENTIALS - Email and Password
    // ========================================================================
    
    /**
     * User's email address - used as the login username.
     * 
     * @Column ATTRIBUTES EXPLAINED:
     * - unique = true: No two users can have the same email (enforced by DB)
     * - nullable = false: Email is required (cannot be NULL in database)
     * 
     * HOW UNIQUENESS WORKS:
     * If you try to save a user with duplicate email:
     * 1. Database throws DataIntegrityViolationException
     * 2. Our code catches this and throws EmailAlreadyExistsException
     * 3. User gets friendly error message: "Email already registered"
     */
    @Column(unique = true, nullable = false)
    private String email;
    
    /**
     * User's password - ALWAYS stored as BCrypt hash, NEVER plain text!
     * 
     * WHY HASH PASSWORDS?
     * - If database is hacked, attackers can't see real passwords
     * - BCrypt is slow by design (prevents brute force attacks)
     * - Each hash includes random "salt" (same password → different hash)
     * 
     * BCRYPT FORMAT: $2a$[cost]$[22-char salt][31-char hash]
     * Example: $2a$10$N9qo8uLOickgx2ZMRZoMyeIj...
     *          ↑   ↑   ↑
     *          │   │   └── Salt + Hash combined
     *          │   └── Cost factor (2^10 = 1024 iterations)
     *          └── BCrypt algorithm identifier
     * 
     * VERIFICATION PROCESS (in login):
     * 1. User enters: "MyPassword123"
     * 2. System loads stored hash from database
     * 3. BCrypt.matches("MyPassword123", storedHash) → true/false
     */
    @Column(nullable = false)  // Password is required
    private String password;
    
    // ========================================================================
    // USER PROFILE - Display name shown to other users
    // ========================================================================
    
    /**
     * User's display name - shown to other users in chat.
     * 
     * @Column(name = "display_name"):
     * Maps this camelCase field to snake_case column in database.
     * - Java field: displayName
     * - Database column: display_name
     * 
     * Without this annotation, JPA would create column "displayName"
     * which doesn't follow database naming conventions.
     * 
     * This field is OPTIONAL (nullable by default) - user can skip it.
     */
    @Column(name = "display_name")
    private String displayName;
    
    // ========================================================================
    // ACCOUNT STATUS - Controls what user can do
    // ========================================================================
    
    /**
     * User's account status - determines if user can log in.
     * 
     * POSSIBLE VALUES:
     * - "PENDING_VERIFICATION": Just registered, email not verified yet
     * - "ACTIVE": Email verified, can log in and use the app
     * - "BANNED": Account disabled by admin (future feature)
     * 
     * LOGIN CHECK IN AuthService:
     * if (!"ACTIVE".equals(user.getStatus())) {
     *     throw new RuntimeException("Email not verified");
     * }
     */
    @Column(nullable = false)  // Status is required
    private String status;  // PENDING_VERIFICATION, ACTIVE
    
    // ========================================================================
    // USER ROLES - For authorization (what user can access)
    // ========================================================================
    
    /**
     * User's roles for authorization (e.g., ["ROLE_USER", "ROLE_ADMIN"]).
     * 
     * WHY A SEPARATE TABLE?
     * One user can have multiple roles, so we need a one-to-many relationship.
     * @ElementCollection creates a separate "user_roles" table automatically.
     * 
     * ANNOTATION BREAKDOWN:
     * 
     * @ElementCollection(fetch = FetchType.EAGER)
     * - Stores a collection of basic types (String) in a separate table
     * - FetchType.EAGER: Load roles immediately when loading user
     * - Alternative: LAZY (load only when getRoles() is called)
     * - We use EAGER because we always need roles for authorization checks
     * 
     * @CollectionTable(name = "user_roles", joinColumns = @JoinColumn(name = "user_id"))
     * - name: The table name for storing roles
     * - joinColumns: Foreign key linking back to users table
     * 
     * @Column(name = "role")
     * - Column name in user_roles table for the role value
     * 
     * RESULTING TABLE STRUCTURE:
     * | user_id | role       |
     * |---------|------------|
     * | 1       | ROLE_USER  |
     * | 1       | ROLE_ADMIN |  ← User 1 has 2 roles
     * | 2       | ROLE_USER  |  ← User 2 has 1 role
     */
    @ElementCollection(fetch = FetchType.EAGER)  // Load roles immediately with user
    @CollectionTable(
        name = "user_roles",  // Table name for roles
        joinColumns = @JoinColumn(name = "user_id")  // Foreign key to users table
    )
    @Column(name = "role")  // Column name for role values
    private List<String> roles;

    // ========================================================================
    // CONSTRUCTORS
    // ========================================================================

    /**
     * Default no-args constructor.
     * 
     * REQUIRED BY JPA! JPA uses reflection to create entity instances:
     * 1. JPA calls: User user = new User();  (uses this constructor)
     * 2. JPA sets fields: user.setEmail(resultSet.getString("email"));
     * 3. JPA returns the populated object
     * 
     * If you remove this constructor, JPA will fail to load User objects!
     */
    public User() {}

    /**
     * Constructor with all required fields - convenient for creating new users.
     * 
     * USAGE EXAMPLE (in AuthService.register):
     * User user = new User(
     *     "john@example.com",                        // email
     *     passwordEncoder.encode("password123"),     // BCrypt hash, NOT plain text!
     *     "John Doe",                                // display name
     *     "PENDING_VERIFICATION",                    // initial status
     *     List.of("ROLE_USER")                       // default role
     * );
     * userRepository.save(user);  // Saves to MySQL
     * 
     * @param email User's email address (must be unique)
     * @param password BCrypt-hashed password (NEVER pass plain text!)
     * @param displayName User's display name (optional, can be null)
     * @param status Account status (PENDING_VERIFICATION, ACTIVE, etc.)
     * @param roles List of roles (ROLE_USER, ROLE_ADMIN, etc.)
     */
    public User(String email, String password, String displayName, String status, List<String> roles) {
        this.email = email;
        this.password = password;
        this.displayName = displayName;
        this.status = status;
        this.roles = roles;
    }

    // ========================================================================
    // GETTERS AND SETTERS
    // ========================================================================
    // Required by JPA for reading/writing field values using reflection.
    // Also used by Jackson for JSON serialization (in API responses).
    
    /** Gets the user's unique ID (null for unsaved entities) */
    public Long getId() { return id; }
    
    /** Sets the user's ID - usually only used internally by JPA */
    public void setId(Long id) { this.id = id; }
    
    /** Gets the user's email address (used as login username) */
    public String getEmail() { return email; }
    
    /** Sets the user's email address */
    public void setEmail(String email) { this.email = email; }
    
    /** Gets the user's password hash (NOT the plain text password!) */
    public String getPassword() { return password; }
    
    /** Sets the user's password - must be BCrypt hash, not plain text! */
    public void setPassword(String password) { this.password = password; }
    
    /** Gets the user's display name shown in chat */
    public String getDisplayName() { return displayName; }
    
    /** Sets the user's display name */
    public void setDisplayName(String displayName) { this.displayName = displayName; }
    
    /** Gets the user's account status (PENDING_VERIFICATION, ACTIVE, etc.) */
    public String getStatus() { return status; }
    
    /** Sets the user's account status - controls login permissions */
    public void setStatus(String status) { this.status = status; }
    
    /** Gets the user's roles for authorization */
    public List<String> getRoles() { return roles; }
    
    /** Sets the user's roles */
    public void setRoles(List<String> roles) { this.roles = roles; }
}

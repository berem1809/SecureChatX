# =============================================================================
# APPLICATION.PROPERTIES - Main configuration file for Spring Boot application
# =============================================================================
# This file contains all configuration settings for the ChatApp backend.
# Spring Boot automatically reads this file at startup.
#
# CONFIGURATION HIERARCHY (in order of precedence):
# 1. Command line arguments (--server.port=9090)
# 2. Environment variables (SERVER_PORT=9090)
# 3. application.properties (this file)
# 4. Default values in code
#
# IMPORTANT: Never commit sensitive values (passwords, API keys) to version control!
# Use environment variables for production deployments.
# =============================================================================

# =============================================================================
# MYSQL DATABASE CONFIGURATION
# =============================================================================
# MySQL stores permanent user data (users, roles, etc.)
# Unlike Redis (temporary), this data persists even after server restart.

# JDBC Connection URL:
# - jdbc:mysql:// - Protocol for MySQL connection
# - localhost:3306 - Server address and port (3306 is MySQL default)
# - /chat_springboot_app - Database name (must exist in MySQL)
# - useSSL=false - Disable SSL for local development (enable in production!)
# - serverTimezone=UTC - Use UTC to avoid timezone issues
# - allowPublicKeyRetrieval=true - Required for some MySQL authentication modes
spring.datasource.url=jdbc:mysql://localhost:3306/chat_springboot_app?useSSL=false&serverTimezone=UTC&allowPublicKeyRetrieval=true

# Database credentials - CHANGE THESE IN PRODUCTION!
spring.datasource.username=root
spring.datasource.password=PiRa$18N

# MySQL JDBC driver class
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# =============================================================================
# JPA / HIBERNATE CONFIGURATION
# =============================================================================
# JPA (Java Persistence API) is used to map Java objects to database tables.
# Hibernate is the JPA implementation we're using.

# DDL-AUTO OPTIONS:
# - none: No action (production - manage schema manually)
# - validate: Validate schema matches entities (production)
# - update: Update schema to match entities (development) ← Current
# - create: Create schema (drops existing data!)
# - create-drop: Create on startup, drop on shutdown (testing)
spring.jpa.hibernate.ddl-auto=update

# Show SQL queries in console (helpful for debugging, disable in production)
spring.jpa.show-sql=true

# MySQL-specific dialect for optimized SQL generation
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQLDialect

# Format SQL queries for readability (disable in production for performance)
spring.jpa.properties.hibernate.format_sql=true

# =============================================================================
# REDIS CONFIGURATION
# =============================================================================
# Redis is an in-memory data store used for:
# - Verification tokens (24-hour TTL)
# - Refresh tokens (30-day TTL)
# 
# WHY REDIS?
# - Extremely fast (in-memory)
# - Built-in TTL (Time-To-Live) - data auto-expires
# - Perfect for temporary authentication data
# - Scales well for distributed systems

# Redis server location (localhost for development)
spring.redis.host=localhost

# Default Redis port (6379 is standard)
spring.redis.port=6379

# =============================================================================
# EMAIL CONFIGURATION (Gmail SMTP)
# =============================================================================
# Used to send verification emails when users register.
# 
# GMAIL SETUP REQUIRED:
# 1. Enable 2-Factor Authentication on your Gmail account
# 2. Generate an "App Password" (not your regular password)
# 3. Use the App Password below
#
# TO GENERATE APP PASSWORD:
# 1. Go to Google Account → Security → 2-Step Verification
# 2. Scroll down to "App passwords"
# 3. Select "Mail" and "Windows Computer"
# 4. Copy the 16-character password

# Gmail SMTP server
spring.mail.host=smtp.gmail.com

# SMTP port 587 = TLS encryption (recommended)
spring.mail.port=587

# Your Gmail address (sender address for verification emails)
spring.mail.username=piranaberem14@gmail.com

# App Password (NOT your Gmail password!) - 16 characters, no spaces
# SECURITY: Use environment variable in production!
spring.mail.password=kehpnsukclgljysh

# Enable SMTP authentication
spring.mail.properties.mail.smtp.auth=true

# Enable STARTTLS (upgrades connection to encrypted)
spring.mail.properties.mail.smtp.starttls.enable=true

# Connection timeouts (milliseconds) - prevent hanging on network issues
spring.mail.properties.mail.smtp.connectiontimeout=5000
spring.mail.properties.mail.smtp.timeout=5000
spring.mail.properties.mail.smtp.writetimeout=5000

# =============================================================================
# SERVER CONFIGURATION
# =============================================================================

# HTTP port (8080 is Spring Boot default)
# Access your API at: http://localhost:8080
server.port=8080

# Application type: servlet = traditional web (vs reactive)
spring.main.web-application-type=servlet

# =============================================================================
# JWT (JSON WEB TOKEN) CONFIGURATION
# =============================================================================
# JWT tokens are used for stateless authentication.
# The secret key is used to sign and verify tokens.

# SECRET KEY - Used to sign JWT tokens
# REQUIREMENTS:
# - At least 64 characters for HS512 algorithm
# - Random and unpredictable
# - NEVER share or commit to version control
# - Rotate periodically in production
#
# SECURITY WARNING: This is an example key. Generate a new one for production!
# Generate with: openssl rand -hex 32 (produces 64 hex characters)
app.jwt.secret=c5066462ce39e0b1cf9c4eb79645f85d6502e06f4851d42490e670b1e6f37db9

# ACCESS TOKEN EXPIRATION (milliseconds)
# 900000 ms = 15 minutes
# Short expiry limits damage if token is stolen
app.jwt.access-expiration-ms=900000

# REFRESH TOKEN EXPIRATION (milliseconds)
# 2592000000 ms = 30 days
# Long expiry for user convenience (stay logged in)
# Can be revoked server-side by deleting from Redis
app.jwt.refresh-expiration-ms=2592000000

# =============================================================================
# LOGGING CONFIGURATION
# =============================================================================
# Controls what information is written to console/log files.
# Levels (from most to least verbose): TRACE > DEBUG > INFO > WARN > ERROR

# Root level: INFO shows normal operation messages
logging.level.root=INFO

# Our application: DEBUG shows detailed execution flow (helpful for development)
logging.level.com.chatapp=DEBUG

# Email debugging: DEBUG shows SMTP communication (useful for troubleshooting)
logging.level.org.springframework.mail=DEBUG

# =============================================================================
# SPRING ACTUATOR CONFIGURATION
# =============================================================================
# Actuator provides production-ready features like health checks, metrics, etc.
# Access at: http://localhost:8080/actuator

# Expose all actuator endpoints (restrict in production!)
management.endpoints.web.exposure.include=*

# Show detailed health information (database, redis connections, etc.)
management.endpoint.health.show-details=always

# Enable Kubernetes-style health probes (/actuator/health/liveness, /readiness)
management.endpoint.health.probes.enabled=true